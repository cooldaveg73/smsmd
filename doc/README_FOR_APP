Use this README file to introduce your application and point to useful places in the API for learning more.
Run "rake doc:app" to generate API documentation for your models, controllers, helpers, and libraries.


=======================================
The following lines describe aspects of my coding style that might be useful in
understanding the application and best practices for working with this system
and Rails in general:

If you're not familiar with Ruby, I use a lot of traditional ruby idioms.
One thing you might be uncomfortable with is 'unless'. It reads pretty weird
to a lot of programmers. But once you get used to it, it is really
comfortable.

I prefer the fatty models and light controllers paradigm. This means I prefer
to put class and instance methods in the models rather than crowd the
controllers. However, this may or may not be your style. The project I
inherited had almost all of the code jammed into controllers. I recommend
putting more code in models and modules and less in controllers.  But just
know, I designed a lot of the code to make sense when you're reading the
controllers. The actual beefy part and edge-case checking was put in the models
and modules.

The hardest part in dealing with vhds is handling the case when they have
more than one case out. The system allows for a vhd to put out multiple
cases. This adds a lot of complexity but is necessary for vhds. It's hard
to really give a vhd a status and/or keep track of all the cases the vhd is
on at the moment. It would be great to store this information in an instance
variable => the current unfinished cases that a vhd has. However, an instance
variable only persists for that request. Once that vhd is pulled out of the
database again, those instance variables are cleared. At the end of every 
request, exit is automatically called. This clears out the whole stack for 
anything on that request. Instance variables are great for storing 
information per request. However, they don't really do much across requests.
One can add this information to the database and query it from there. But at
that point, you might as well set up a query (which is what I did). You can
however use class instance variables. But avoid their overuse. They persist 
through all requests and are stored as global data (I believe). 
Also, they are not configured for security. They open up avenues for 
buffer overflow, etc.

I strongly recommend setting up queries in conjunction. Setting up database
calls for performance is a science. However, one quick thing you can do
is set up queries together. This allows for the mysql software to do its 
magic (i.e. inner-join) and limit. Examples:
1) 
Bad way:
cases = Case.where("vhd_id = ?", vhd.id)
cases = cases.where('status = "Accepted"')
Better way:
cases = Case.where(["vhd_id = ?", 'status = "Accepted"'].join(' AND '), self.id)
Equally as good (due to rails gems):
cases = Case.where("vhd_id = ?").where('status = "Accepted"')
Side note: The log/development.log is the best way to judge the relative
expensiveness of these calls. 

Personally, I think it's worth spending the time setting up complex
find_by_sql calls for really complex queries. But again, this is only for
cases where calls get out of hand and ActiveRecord is getting better and
better at handling queries.

I ran into this huge issue recently with how to scale this multi-tenant
application. It really makes no sense for every new project to have to parse
through different data for all the different applications. I think the main
issue here is that Rails is not a great framework for multiple databases or
multi-tenant behavior within one database. I did some research on this.  In
order to have one database load different data for a new project, we would have
to switch to PostgreSQL. Loading a new database for every project is doable,
but would require time on the programmer's end. This could be factored out to a
script, but I think this would introduce complexity.  My end-goal is to have
Pooja click buttons to launch a project on her own and select through options
to launch a new project. I estimate adding an index in MySQL for every the
project_id should suffice for a long time.

I put some code in the config/initializers file. I put a constants file. It 
really makes no sense to define constants in a model because the scope is 
global anyway. If we want to use ALL_CAPS or $constants, then we ought to
put them here. @@class_instance_variables should be kept in models. I also
put a file called active_record_patch. I don't recommend overriding existing
functions in the active record. So I limited it to only these two cases.
This way we can centralize what we do with this error.

The save! vs save thing is really a preference. save! produces a backtrace.

Handling scribed messages from vhd is not so elegant right now. The big design
issue is that a vhd can have multiple cases running at the same time. A
vhd can send in multiple req sms and can potentially be trying to answer a
question for any of those doctors have accepted any of those req sms. If a vhd
is trying to answer a doctor's question, the only way the system can know
where that answer goes to is if it is unambiguous. Note: this can potentially
be solved using timing options. The way this would work is it checks to see if
something occured in the last ten minutes and thus the system can be a little
smarter at understanding what's going on. My experience in the field tells me
that this is not a great indicator. VHD's or Doctor's may just take a while
to respond to things anyway. But like I said, it might just make the system
slightly smarter.

Side note: time. Right now there is no convention in the system for what type
of time objects to use. SQL uses datetime objects. Ruby favors time objects.
UTC integers are the easiest to deal with. I haven't put much thought into
an overall design of this. But we must be extra careful when doing things such
as beginning_of_day. I'll try to make a list of the design decisions related to
time objects at some point and which areas use which timezone/object type. It
is pretty annoying to have .utc or .to_i or .to_datetime everywhere in the code
so I will put some more thought to this once we extend and finalize our
cases a little bit more. Obviously utc times aren't really useful for the
user. Beware of using Time.now and other functions on the server. It runs on
UTC time. Time.local also produces UTC times on the server. Don't use Time.now
or Time.local in conclusion unless you convert it right after.

Factories are worth getting used to. The reason to use them is that you can
create data in your code so you can have a better idea of what your tests
are doing (and debug tests). One thing that took me a while to figure out
is that if you want the factory to set up any sort of dynamic data, you have
to set it up with {}. You may notice in my factories.rb file that the syntax
looks sort of weird when there is a brackets for something like f.mobile. But
this is the only way to produce dynamic data. The reason for this is that
every factory is a class and every time the factory framework is loaded
it generates all this class information. So a method like random_mobile
is only called once. When you use { } you are generating a
dynamic method that will be called when new classes are created. Fortunately,
much of this is handled when you call things like f.association.

NOTE: a doctor can only be accepted on one case at a time, 
otherwise fin becomes complicated

Right now, I am using the helpers for organization only. I think the real 
purpose is to have methods available in views and across controllers.

This isn't necessarily standard, but I usually use message to mean a Message
object. So if I say formatted_message or acc_message, that generally
means the object. When I use msg, that means the content from a message
object. So something like req_format_msg will likely form the content of
a message object. When I use something like text, that usually means some
kind of raw detached string. It's lone and unformatted.

You may find situations where it is annoying to change the data model in order
to accomodate the data that someone wants to track. For example, making
something a method versus keeping it in a field. Hopefully I create some kind
of framework for storing old data without the overhead of making the old data
work with the new methods of retreiving data. A good example is how I
calculated response time for a case. I would like to simply use
time_accepted - time_opened. Rather than parse through all the data with
exceptions every time I come up with a new scheme, I would rather focus on
testing the code and figuring out how to get my desired method to work (aka
log data properly). However, I have yet to figure out an elegant way to keep
that information stored over time. I could make a model, but I would rather
have the data be more dynamic. I can explain more if this is unclear.

It's really hard to generate data for tests...sucks

A caller to the doctor method pageable should still check to see if that
doctor is available. Pageable is sort of like, can they be paged if they need
to, not is this a good doctor to page.

Be careful with lambda blocks. They are great for things like should change
but they don't produce errors in rspec, because you're supposed to be able
to test for errors with lambdas. My advice is to only use lambda blocks when
you are testing for an error.

My opinion on methods versus attributes: if you are using something for data 
collection, you should make it an attribute and store it (that way you don't 
have to call methods to get it). If you are using something like once per 
request, it is best to make it a method. That way, you don't over complicate
the database.

I had a pretty malicious bug when I called an attribute for a demoer :type.
Apparently this invokes class inheritance in Ruby. So when I went to clear out
all the demoers, it ended up deleting vhds. Long story short, don't name
anything in a model :type.

I put the HTTP call necessary for sending messages in the messages model. If
you're into looking into file changes, you'll see that it used to be a
separate file, but I thought this way was more organized.

The way timezones are stored for projects is designed so that it can be used 
like DateTime.now.new_offset(project.time_zone / 24) for datetime objects and
like time.in_time_zone(project.time_zone.hours) for time objects.

I'm changing the sender model to be only the VHDs can send in REQ and HLP
requests. This makes it easier to identify who is sending in information. This
way you can parse an incoming message to either a doctor and a vhd and
eventually a pm. It caused a lot of errors when we were allowing patients to
send in messages (VHD's would put in their number as the patient's number).
This way, everyone who can send in messages to the system can be registered as
such.

Watch your before filters when accepting incoming messages.

Remembering the Ruby is extremely object oriented, one of the nastiest bugs I
had was when I initialized two arrays on the same line like so:
@doctors = @vhds = []
This stored these as the same array object under the hood. It's much better to
do it like so:
@doctors, @vhds = [], []
or
@doctors = []
@vhds = []
